# 4주차 - 신현철

## 💡 학습 키워드

- 인덱스

## 📚 학습 정리

- 인덱스 스캔 방향
    - 정순 : 인덱스 생성과 스캔 방향이 같은 것
    - 역순 : 인덱스 생성과 스캔 방향이 반대
    - 기본적으로 페이지 내 레코드 간 연결이 단방향이기 때문에 정순 스캔이 빠름. → 자주 사용되는 쿼리에 따라 인덱스 생성하는 것이 바람직함.
- 인덱스 가용성과 효율성
    - 쿼리의 조건절을 `작업 범위 결정 조건`으로 만드는 것이 중요함. (작업의 범위를 결정하는 조건)
    - `필터링 조건(체크 조건)`은 쿼리의 처리 성능을 악화시킨다.
    - 가용성과 효율성 판단
        - 인덱스 사용 불가능 조건
            - NOT-EQUAL
            - LIKE ‘%suffix’
            - 스토어드 함수나 연산자로 칼럼 변형
            - NOT-DETERMINISTIC 함수
            - 다른 타입 간의 비교 (타입 변환 후 비교)
            - 문자열 데이터 타입의 collation이 다른 경우
        - 작업 범위 결정 조건으로 인덱스 사용하는 경우
            - 이전 컬럼들이 동등 비교 형태로 비교됨
            - 현재 컬럼을 다음 중 하나로 비교
                - 동등 비교 ( `=` , `IN`)
                - 크다 작다 형태 (`>` , `<`)
                - LIKE prefix 형태
- R-Tree
    - MBR을 사용해서 2차원 좌표 값 효율적으로 저장
    - `ST_contain()` 또는 `ST_Within()` 등과 같은 포함 관계 비교 함수로 검색
- 전문 검색
    - 일반적인 B-Tree 인덱스는 3072B까지만 컬럼 값 사용하므로 전문 검색에는 부적합함.
    - Full Text 검색에는 Full Text Search Index를 사용한다.
    - 어근 분석 + 불용어 처리하는 원리
    - 불용어는 언어별로 효율성이 극과극이므로 커스텀하는 것이 좋다.
- 함수 기반 인덱스
    - Virtual 컬럼 → 테이블 구조를 변경함.
    - 함수 기반 인덱스 → 조건절에도 그대로 함수를 동일하게 사용해야 인덱스 이용가능.
- 클러스터링 인덱스
    - 테이블 레코드를 PK 기준으로 묶어서 저장하는 방식 → 저장 위치가 PK에 따라 결정됨.
    - InnoDB 엔진에서만 지원한다.
    - 클러스터링 인덱스 = 클러스터링 테이블 = 클러스터링 키
    - 키 기반 조회가 빠른 장점을 갖지만, `insert`, PK의 `update`는 상대적으로 느리다.
    - PK는 가능한 명시적으로 생성하는 것이 좋다. 따라서 기본키가 마땅히 없으면 `auto-increment`라도 넣자(Surrogate Key). (PK 명시 안해도 묵시적으로 생성되지만, 숨겨지고 사용자가 접근이 불가능해서 비효율적임)
    - OLTP 환경에서는 쓰기가 훨씬 많음 → 클러스터링 인덱스가 효율적이다.
    - 클러스터링 테이블에서는 세컨더리 인덱스의 리프는 PK 값을 갖고 있게됨 → 리프까지 탐색 후 다시 PK 인덱스 재탐색해서 데이터 레코드 조회.
- 유니크 인덱스
    - 중복이 없는 컬럼
    - `UNIQUE` 제약 조건이 걸리면 인덱스가 자동 생성됨.
    - `NULL`은 중복 허용
    - `INSERT` , `UPDATE`시에 중복 체크 과정이 추가된다. → 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느림 → 중복 체크 시에 읽기 잠금 사용, 쓰기할 때는 쓰기 잠금 사용 → 데드락이 자주 발생함.
    - 유니크 인덱스와 논 유니크 세컨더리 인덱스 간의 조회 속도도 크게 차이 X
    - 따라서 무조건 성능 상의 이점이 있는 것이 아니다.
- 외래키
    - 외래키 제약이 설정되면 자동으로 외래키에 대한 인덱스까지 생성된다.
    - 외래키 제약으로 인한 잠금 확장은 성능에 큰 영향을 주므로 사용하지 않는 것도 고려하자.
    - InnoDB FK 관리
        - 테이블의 변경이 발생할 때만 잠금 경합 발생한다.
            - 부모 테이블의 레코드가 쓰기 잠금이 걸림 → 자식은 해당 쓰기 잠금 해제를 기다림
        - FK와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합을 발생시키지 않는다.
            - FK가 아닌 칼럼 값의 변경은 잠금 확장 X
    - 실무에서 외래키를 사용하지 않는 이유?
        - 무결성, 정합성의 희생해 개발 편의성과 확장성을 챙기기
        
        [외래키를 사용하지 않는 이유 feat. 인덱스](https://co1nam.tistory.com/44)
        
        [실무에서 외래키를 사용하지 않는 이유가 궁금합니다. - 인프런 | 질문 & 답변](https://www.inflearn.com/questions/629396/실무에서-외래키를-사용하지-않는-이유가-궁금합니다)
        

## 🗂️ 참고자료

[외래키를 사용하지 않는 이유 feat. 인덱스](https://co1nam.tistory.com/44)

[실무에서 외래키를 사용하지 않는 이유가 궁금합니다. - 인프런 | 질문 & 답변](https://www.inflearn.com/questions/629396/실무에서-외래키를-사용하지-않는-이유가-궁금합니다)